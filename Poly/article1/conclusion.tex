In conclusion, this research developed a solution that showed the possibility to use clustering mechanisms without a human intervention to find causes of performance problems. As a contribution for developers, this  paper  introduces  the  visualization  tool  for  the  Calling Context Tree with Flame Graphs and Auto Cluster mechanisms. \\
The clustering data was built through a bottom-up analysis on collected stack traces, from recorded tracing data on ECCTs. This data structure, was implemented in the CCT View inside TraceCompass framework and provides several run-time properties of the studied software.\\
% The implementation also developed the RGG differential flamegraph to compare groups of executions. This implementation uses a three colors: red, green and gray, which is a different approach of the original work, but was done to avoid ambiguity between slower executions and equal time executions.
The solution presented an automated algorithm done with an heuristic comparison. This approach is the first one to be done on performance analysis on trace executions and call graph data. The solution also presented a flexible approach which can be used combined with different means to collect the data, as LTTng and Perf counter to form the data that will be analyzed, as was done in some use cases.
The grouping approach used was used  without supervision. This is an advantage over techniques that require training phase. For example, Support Vector Machines, which require data pre-classification. \\

This paper also did a comparison among the possible techniques that can be used for this kind of operation. In the comparison the techniques that were non-supervised required another level of data treatment, for example the SVM technique, and therefore can be overpassed by the auto clustering technique, suggested here.

Our work was able to find causes of performance issues without human intervention and can be applied to other cases to find other problems. The implementation as part of the TraceCompass framework aims to apply this approach for more cases and large scale software analysis.

As future work, we plan to expand our investigation by using non-linear models to track regression problems in different software versions \cite{deep}. This can be used as an automated test to find software regressions. An example of possible models are feed-forward network \cite{deep}, also called deep learning networks.
The models need to be able to characterize specifically non-linear dependencies and be able to be used without non label data. Considering those restrictions, an Autoencoder or a Restricted Boltzmann Machine are also candidates.\\ 
%This require modifications in the loss function.

Another possibility would be to apply other techniques such as Apriori algorithm as described in \cite{apriori}, which can determine association rules among the metrics recorded in the enhanced CCT, for each cluster. Finally, tracking performance issues before the release of new software is an interesting path to be followed. Thus, an automated mechanism to find them before the release of a new version of software is very promising. A possibility could be to develop a mechanism to be executed as a regression test suite, from the machine learning models described above, before the releasing.